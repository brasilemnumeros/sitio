---
layout: default
title: In√≠cio
---

<div class="w-full overflow-x-hidden">
  <div class="chart-container w-full bg-white px-4 shadow-lg dark:bg-gray-700" id="chart-container">
    <div id="loading-indicator" class="hidden py-12 text-center">
      <div class="inline-block h-8 w-8 animate-spin rounded-full border-b-2 border-blue-600"></div>
      <p class="mt-2 text-gray-600 dark:text-gray-200">Carregando dados...</p>
    </div>
    <canvas id="chart" class="h-full w-full"></canvas>
  </div>
  <div class="mt-3 mb-4 text-center">
    <p id="data-source" class="text-sm">
      <span class="font-medium">Fonte:</span> <span id="source-name">Banco Central do Brasil</span>
    </p>
  </div>
</div>

<script>
  let chart; // Global variable to store the chart instance
  let indicatorsConfig; // Global variable to store indicators configuration

  // Function to calculate and set optimal chart height
  function setChartHeight() {
    const chartContainer = document.getElementById('chart-container');
    const containerRect = chartContainer.getBoundingClientRect();
    const viewportHeight = window.innerHeight;
    const footerHeight = 100; // Estimated footer height + some padding

    // Calculate available height from current position to bottom of viewport
    const availableHeight = viewportHeight - containerRect.top - footerHeight;

    // Set minimum and maximum heights
    const minHeight = 400;
    const maxHeight = 800;

    // Calculate optimal height
    const optimalHeight = Math.max(minHeight, Math.min(maxHeight, availableHeight));

    chartContainer.style.height = optimalHeight + 'px';
  }

  async function loadIndicatorsConfig() {
    try {
      let baseUrl =
        '{% if jekyll.environment == "development" %}http://localhost:4000{% else %}{{ site.url }}{% endif %}';
      if (baseUrl.endsWith('/')) {
        baseUrl = baseUrl.slice(0, -1);
      }
      const response = await fetch(baseUrl + '/indicators.json');
      const config = await response.json();
      return config;
    } catch (error) {
      console.error('Error loading indicators config:', error);
      // Fallback to default configuration if loading fails
      return {};
    }
  }

  function clearChart() {
    // Destroy existing chart if it exists
    if (chart) {
      chart.destroy();
      chart = null;
    }
    
    // Clear the canvas
    const canvas = document.getElementById('chart');
    if (canvas) {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
    
    // Update data source to show empty state
    const sourceElement = document.getElementById('source-name');
    if (sourceElement) {
      sourceElement.textContent = 'Selecione um indicador para visualizar os dados';
    }
    
    console.log('Chart cleared');
  }

  function populateSelector(config) {
    // Setup global function for multiselect communication
    window.updateChartsFromMultiselect = function(selectedIndicators, indicatorMap, forceClear = false) {
      console.log('Selected indicators:', selectedIndicators, 'Force clear:', forceClear);
      
      if (selectedIndicators.length === 0 || forceClear) {
        // Se nenhum selecionado OU force clear, limpar o gr√°fico
        console.log('No indicators selected or force clear - clearing chart');
        clearChart();
        return;
      }
      
      // Preparar arrays de arquivos e nomes
      const dataFiles = selectedIndicators.map(indicator => indicatorMap[indicator]).filter(Boolean);
      const indicatorNames = selectedIndicators.slice(); // Copy array
      
      if (dataFiles.length === 0) {
        console.error('No valid data files found for selected indicators');
        return;
      }
      
      // Atualizar gr√°fico com m√∫ltiplos indicadores
      if (dataFiles.length === 1) {
        console.log('Single indicator selected:', indicatorNames[0]);
        updateChart(dataFiles[0], indicatorNames[0]);
      } else {
        console.log('Multiple indicators selected:', indicatorNames);
        updateChart(dataFiles, indicatorNames);
      }
    };
    
    // Store config globally for other functions to use
    window.indicatorsConfig = config;
    
    return config;
  }

  function updateDataSource(selectedFiles) {
    const sourceElement = document.getElementById('source-name');
    if (!sourceElement) return;
    
    // Support both single file and multiple files
    const filesArray = Array.isArray(selectedFiles) ? selectedFiles : [selectedFiles];
    
    // Collect unique sources
    const sources = new Set();
    
    filesArray.forEach(selectedFile => {
      // First try to get source from indicators config
      if (window.indicatorsData && window.indicatorsData.indicators) {
        const indicator = window.indicatorsData.indicators.find(ind => ind.datafile === selectedFile);
        if (indicator && indicator.source) {
          sources.add(indicator.source);
          return;
        }
      }
      
      // Fallback to hardcoded mapping if config not available
      const sourceMap = {
        'https://brasilemnumeros.github.io/dados/selic/selic-acum-12m.json': 'Banco Central do Brasil',
        'https://brasilemnumeros.github.io/dados/ipca/ipca-acum-12m.json': 'Instituto Brasileiro de Geografia e Estat√≠stica (IBGE)',
        '/data/selic-acum-12m.json': 'Banco Central do Brasil',
        '/data/ipca-acum-12m.json': 'Instituto Brasileiro de Geografia e Estat√≠stica (IBGE)'
      };
      
      const source = sourceMap[selectedFile] || 'Banco Central do Brasil';
      sources.add(source);
    });
    
    // Display sources
    const sourcesArray = Array.from(sources);
    if (sourcesArray.length === 1) {
      sourceElement.textContent = sourcesArray[0];
    } else if (sourcesArray.length > 1) {
      sourceElement.textContent = sourcesArray.join(' | ');
    } else {
      sourceElement.textContent = 'Banco Central do Brasil';
    }
  }

  async function loadData(dataFile) {
    try {
      // Show loading indicator
      const loadingIndicator = document.getElementById('loading-indicator');
      const chartCanvas = document.getElementById('chart');

      loadingIndicator.classList.remove('hidden');
      chartCanvas.style.opacity = '0.3';

      let baseUrl = '';
      if (!dataFile.startsWith('http')) {
        baseUrl =
          '{% if jekyll.environment == "development" %}http://localhost:4000{% else %}{{ site.url }}{% endif %}';
        if (baseUrl.endsWith('/')) {
          baseUrl = baseUrl.slice(0, -1);
        }
      }
      const response = await fetch(baseUrl + dataFile);
      const jsonData = await response.json();

      // Hide loading indicator
      loadingIndicator.classList.add('hidden');
      chartCanvas.style.opacity = '1';

      return jsonData;
    } catch (error) {
      console.error('Error loading data:', error);

      // Hide loading indicator on error
      const loadingIndicator = document.getElementById('loading-indicator');
      const chartCanvas = document.getElementById('chart');

      loadingIndicator.classList.add('hidden');
      chartCanvas.style.opacity = '1';

      return null;
    }
  }

  function createChart(jsonDataArray, indicatorNames = null) {
    // Support both single indicator (legacy) and multiple indicators
    const isMultipleIndicators = Array.isArray(jsonDataArray);
    const dataArray = isMultipleIndicators ? jsonDataArray : [jsonDataArray];
    const namesArray = isMultipleIndicators ? indicatorNames : [indicatorNames || jsonDataArray.indicatorName];

    // Check if dark mode is active
    const isDark = document.documentElement.classList.contains('dark');

    // Define colors based on theme
    const titleColor = isDark ? '#f9fafb' : '#1f2937';
    const axisLabelColor = isDark ? '#f9fafb' : '#1f2937';
    const ticksColor = isDark ? '#d1d5db' : '#374151';
    const gridColor = isDark ? '#4b5563' : '#e5e7eb';

    // Color palette for multiple indicators
    const colorPalette = [
      'rgba(59, 130, 246, 0.8)',   // Blue
      'rgba(239, 68, 68, 0.8)',    // Red
      'rgba(34, 197, 94, 0.8)',    // Green
      'rgba(168, 85, 247, 0.8)',   // Purple
      'rgba(249, 115, 22, 0.8)',   // Orange
      'rgba(236, 72, 153, 0.8)',   // Pink
    ];

    // Create datasets for each indicator
    const datasets = dataArray.map((jsonData, index) => {
      const chartData = jsonData.data;
      const indicatorName = namesArray[index] || jsonData.indicatorName;
      const color = colorPalette[index % colorPalette.length];
      
      const allDataPoints = chartData.map((item) => ({
        x: item.date || item.year,
        y: item.rate,
      }));

      return {
        label: indicatorName,
        data: allDataPoints,
        borderColor: color,
        backgroundColor: color.replace('0.8', '0.1'),
        fill: false,
        tension: 0.1,
        borderWidth: 3,
        pointRadius: 0,
        pointHoverRadius: 6,
        pointBackgroundColor: color,
        pointBorderColor: 'rgba(255, 255, 255, 0.8)',
        pointBorderWidth: 2,
        yAxisID: isMultipleIndicators && index > 0 ? 'y1' : 'y',
      };
    });

    // Chart title - combine names for multiple indicators
    const chartTitle = isMultipleIndicators && namesArray.length > 1
      ? `Compara√ß√£o: ${namesArray.map(name => name.replace(/^[üè¶üìà]\s/, '')).join(' vs ')}`
      : (namesArray[0] || 'Indicador');

    // Create annotations for government period boundaries
    const annotations = {};

    // Background boxes for government periods
    annotations['fhc_box'] = {
      type: 'box',
      xMin: '1995-01-01',
      xMax: '2003-01-01',
      backgroundColor: 'rgba(255, 99, 132, 0.1)',
      borderColor: 'rgba(255, 99, 132, 0.3)',
      borderWidth: 1,
    };
    annotations['lula1_box'] = {
      type: 'box',
      xMin: '2003-01-01',
      xMax: '2011-01-01',
      backgroundColor: 'rgba(54, 162, 235, 0.1)',
      borderColor: 'rgba(54, 162, 235, 0.3)',
      borderWidth: 1,
    };
    annotations['dilma_box'] = {
      type: 'box',
      xMin: '2011-01-01',
      xMax: '2016-08-01',
      backgroundColor: 'rgba(255, 206, 86, 0.1)',
      borderColor: 'rgba(255, 206, 86, 0.3)',
      borderWidth: 1,
    };
    annotations['temer_box'] = {
      type: 'box',
      xMin: '2016-08-01',
      xMax: '2019-01-01',
      backgroundColor: 'rgba(75, 192, 192, 0.1)',
      borderColor: 'rgba(75, 192, 192, 0.3)',
      borderWidth: 1,
    };
    annotations['bolsonaro_box'] = {
      type: 'box',
      xMin: '2019-01-01',
      xMax: '2023-01-01',
      backgroundColor: 'rgba(153, 102, 255, 0.1)',
      borderColor: 'rgba(153, 102, 255, 0.3)',
      borderWidth: 1,
    };
    annotations['lula2_box'] = {
      type: 'box',
      xMin: '2023-01-01',
      xMax: '2025-12-31',
      backgroundColor: 'rgba(255, 159, 64, 0.1)',
      borderColor: 'rgba(255, 159, 64, 0.3)',
      borderWidth: 1,
    };

    // Text labels for government periods
    annotations['fhc_label'] = {
      type: 'label',
      xValue: '1999-01-01',
      yValue: 'max',
      content: ['FHC'],
      backgroundColor: 'rgba(255, 99, 132, 0.4)',
      color: 'white',
      font: {
        size: 12,
        weight: 'bold',
      },
      padding: 4,
      borderRadius: 4,
    };
    annotations['lula1_label'] = {
      type: 'label',
      xValue: '2007-01-01',
      yValue: 'max',
      content: ['Lula'],
      backgroundColor: 'rgba(54, 162, 235, 0.4)',
      color: 'white',
      font: {
        size: 12,
        weight: 'bold',
      },
      padding: 4,
      borderRadius: 4,
    };
    annotations['dilma_label'] = {
      type: 'label',
      xValue: '2013-09-01',
      yValue: 'max',
      content: ['Dilma'],
      backgroundColor: 'rgba(255, 206, 86, 0.4)',
      color: isDark ? '#1f2937' : '#6b7280',
      font: {
        size: 12,
        weight: 'bold',
      },
      padding: 4,
      borderRadius: 4,
    };
    annotations['temer_label'] = {
      type: 'label',
      xValue: '2017-09-01',
      yValue: 'max',
      content: ['Temer'],
      backgroundColor: 'rgba(75, 192, 192, 0.4)',
      color: 'white',
      font: {
        size: 12,
        weight: 'bold',
      },
      padding: 4,
      borderRadius: 4,
    };
    annotations['bolsonaro_label'] = {
      type: 'label',
      xValue: '2021-01-01',
      yValue: 'max',
      content: ['Bolsonaro'],
      backgroundColor: 'rgba(153, 102, 255, 0.4)',
      color: 'white',
      font: {
        size: 12,
        weight: 'bold',
      },
      padding: 4,
      borderRadius: 4,
    };
    annotations['lula2_label'] = {
      type: 'label',
      xValue: '2024-01-01',
      yValue: 'max',
      content: ['Lula'],
      backgroundColor: 'rgba(255, 159, 64, 0.4)',
      color: 'white',
      font: {
        size: 12,
        weight: 'bold',
      },
      padding: 4,
      borderRadius: 4,
    };

    // Get unit from first JSON data or use default
    let yAxisTitle = dataArray[0].yAxisTitle || 'Taxa (%)';

    const ctx = document.getElementById('chart').getContext('2d');

    // Destroy existing chart if it exists
    if (chart) {
      chart.destroy();
    }

    chart = new Chart(ctx, {
      type: 'line',
      data: {
        datasets: datasets,
      },
      options: {
        plugins: {
          legend: {
            display: isMultipleIndicators && datasets.length > 1,
            position: 'bottom',
            labels: {
              color: titleColor,
              font: {
                size: 12,
              },
              usePointStyle: true,
            },
          },
          annotation: {
            annotations: annotations,
          },
          title: {
            display: true,
            text: chartTitle,
            font: {
              size: 18,
            },
            color: titleColor,
          },
          tooltip: {
            callbacks: {
              title: function (context) {
                const date = new Date(context[0].parsed.x);
                return date.toLocaleDateString('pt-BR', {
                  year: 'numeric',
                  month: 'long',
                });
              },
              label: function(context) {
                return `${context.dataset.label}: ${context.parsed.y.toFixed(2)}%`;
              },
            },
          },
        },
        scales: {
          x: {
            type: 'time',
            time: {
              unit: 'year',
              displayFormats: {
                year: 'yyyy',
              },
            },
            min: '1995-01-01',
            max: '2025-12-31',
            title: {
              display: true,
              text: 'Ano',
              color: axisLabelColor,
            },
            ticks: {
              color: ticksColor,
            },
            grid: {
              color: gridColor,
            },
          },
          y: {
            type: 'linear',
            display: true,
            position: 'left',
            beginAtZero: false,
            title: {
              display: true,
              text: isMultipleIndicators ? (dataArray[0].yAxisTitle || 'Taxa (%)') : yAxisTitle,
              color: axisLabelColor,
            },
            ticks: {
              color: ticksColor,
            },
            grid: {
              color: gridColor,
            },
          },
          ...(isMultipleIndicators && datasets.length > 1 && {
            y1: {
              type: 'linear',
              display: true,
              position: 'right',
              beginAtZero: false,
              title: {
                display: true,
                text: dataArray[1]?.yAxisTitle || 'Taxa (%)',
                color: axisLabelColor,
              },
              ticks: {
                color: ticksColor,
              },
              grid: {
                drawOnChartArea: false,
              },
            }
          }),
        },
        maintainAspectRatio: false,
        layout: {
          padding: {
            top: 20,
            bottom: 20,
            left: 10,
            right: 40,
          },
        },
        interaction: {
          intersect: false,
          mode: 'index',
        },
        elements: {
          point: {
            hoverRadius: 8,
          },
        },
      },
    });
  }

  async function updateChart(dataFiles, indicatorNames = null) {
    // Support both single file (legacy) and multiple files
    const isMultipleFiles = Array.isArray(dataFiles);
    const filesArray = isMultipleFiles ? dataFiles : [dataFiles];
    const namesArray = isMultipleFiles ? indicatorNames : [indicatorNames];
    
    // Add visual feedback during chart update
    const canvas = document.getElementById('chart');
    if (canvas) {
      canvas.style.transition = 'opacity 0.3s ease-in-out';
      canvas.style.opacity = '0.3';
    }
    
    try {
      // Load all data files in parallel
      const jsonDataPromises = filesArray.map(file => loadData(file));
      const jsonDataArray = await Promise.all(jsonDataPromises);
      
      // Filter out null responses (failed loads)
      const validData = jsonDataArray.filter(data => data !== null);
      
      if (validData.length > 0) {
        // Small delay to let the fade-out complete
        setTimeout(() => {
          // Prepare indicator names
          const finalNames = validData.map((jsonData, index) => {
            if (namesArray && namesArray[index]) {
              return namesArray[index];
            }
            
            // Try to find name from config
            const dataFile = filesArray[index];
            const indicator = window.indicatorsConfig?.indicators?.find((ind) => ind.datafile === dataFile);
            return indicator ? indicator.name : jsonData.indicatorName;
          });

          // Create chart with multiple datasets or single dataset
          if (validData.length === 1) {
            createChart(validData[0], finalNames[0]);
          } else {
            createChart(validData, finalNames);
          }
          
          // Update data source (use first indicator for now)
          updateDataSource(filesArray[0]);
          
          // Restore canvas opacity
          if (canvas) {
            canvas.style.opacity = '1';
          }
        }, 150);
      } else {
        console.error('No valid data loaded');
        // Restore canvas opacity on error
        if (canvas) {
          canvas.style.opacity = '1';
        }
      }
    } catch (error) {
      console.error('Error updating chart:', error);
      // Restore canvas opacity on error
      if (canvas) {
        canvas.style.opacity = '1';
      }
    }
  }

  // Initialize the page
  (async function () {
    // Set initial chart height
    setChartHeight();

    // Load indicators configuration first
    indicatorsConfig = await loadIndicatorsConfig();

    // Setup multiselect functionality
    populateSelector(indicatorsConfig);

    // Load initial data using the default indicator
    const defaultIndicator = indicatorsConfig.indicators.find((ind) => ind.id === indicatorsConfig.defaultIndicator);
    const initialFile = defaultIndicator ? defaultIndicator.datafile : '/data/selic-acum-12m.json';
    
    // Always load the default chart on page load
    await updateChart(initialFile);

    // Add observer for theme changes to update chart colors
    const observer = new MutationObserver(function (mutations) {
      mutations.forEach(function (mutation) {
        if (mutation.attributeName === 'class') {
          // Theme changed, update chart if it exists
          if (chart) {
            const isDark = document.documentElement.classList.contains('dark');

            // Update title color
            chart.options.plugins.title.color = isDark ? '#f9fafb' : '#1f2937';

            // Update axes colors
            chart.options.scales.x.title.color = isDark ? '#f9fafb' : '#1f2937';
            chart.options.scales.x.ticks.color = isDark ? '#d1d5db' : '#374151';
            chart.options.scales.x.grid.color = isDark ? '#4b5563' : '#e5e7eb';

            chart.options.scales.y.title.color = isDark ? '#f9fafb' : '#1f2937';
            chart.options.scales.y.ticks.color = isDark ? '#d1d5db' : '#374151';
            chart.options.scales.y.grid.color = isDark ? '#4b5563' : '#e5e7eb';

            // Update y1 axis colors if it exists
            if (chart.options.scales.y1) {
              chart.options.scales.y1.title.color = isDark ? '#f9fafb' : '#1f2937';
              chart.options.scales.y1.ticks.color = isDark ? '#d1d5db' : '#374151';
            }

            // Update Dilma label color based on theme
            if (chart.options.plugins.annotation.annotations.dilma_label) {
              chart.options.plugins.annotation.annotations.dilma_label.color = isDark ? '#1f2937' : '#6b7280';
            }

            // Update the chart
            chart.update('none');
          }
        }
      });
    });

    // Start observing theme changes
    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['class'],
    });

    // Add window resize listener to adjust chart height
    window.addEventListener('resize', () => {
      setChartHeight();
      if (chart) {
        chart.resize();
      }
    });
  })();
</script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script
  src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"
></script>
<script
  src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation/dist/chartjs-plugin-annotation.min.js"
></script>
